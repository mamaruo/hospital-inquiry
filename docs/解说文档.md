# 在线问诊系统 - 演示解说文档

本文档为在线问诊系统的演示解说词，涵盖用户注册、医生工作、问诊流程等核心功能的代码解析。

---

## 目录

1. [患者端功能区介绍](#一患者端功能区介绍)
2. [医生端功能区介绍](#二医生端功能区介绍)
3. [完整问诊流程演示](#三完整问诊流程演示)
4. [重要设计说明](#四重要设计说明)

---

## 一、患者端功能区介绍

### 1.1 用户注册

用户通过填写姓名、手机号、身份证号和密码完成注册。系统默认将新用户角色设置为 `PATIENT`（患者）。

**演示内容：** 打开注册页面，填写表单，点击"创建账户"完成注册。

**后端控制器 - 注册接口（UserController.java）**
```java
@RestController
public class UserController {
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @PostMapping("/signup")
    public UserResponse signup(@RequestBody User user) {
        return userService.signup(user);
    }

    @PostMapping("/login")
    public LoginResponse login(@RequestBody LoginRequest request) {
        return userService.verify(request);
    }
}
```

**后端服务层 - 注册逻辑（UserService.java）**
```java
@Service
public class UserService {
    private final UserRepository userRepo;
    private final PasswordEncoder passwordEncoder;
    private final AuthenticationManager authenticationManager;
    private final JwtService jwtService;

    public UserResponse signup(User user) {
        // 检查手机号是否已存在
        if (userRepo.findByMobile(user.getMobile()).isPresent()) {
            throw new IllegalArgumentException("该手机号已被注册");
        }
        // 检查身份证号是否已存在
        if (user.getIdCard() != null && userRepo.findByIdCard(user.getIdCard()).isPresent()) {
            throw new IllegalArgumentException("该身份证号已被注册");
        }
        // 密码加密存储
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        User savedUser = userRepo.save(user);
        return UserResponse.fromUser(savedUser);
    }

    public LoginResponse verify(LoginRequest request) {
        try {
            var auth = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(request.mobile(), request.password()));
            if (auth.isAuthenticated()) {
                String token = jwtService.generateToken(request.mobile());
                User user = userRepo.findByMobile(request.mobile())
                    .orElseThrow(() -> new IllegalStateException("用户不存在"));
                return new LoginResponse(token, UserResponse.fromUser(user));
            }
        } catch (BadCredentialsException e) {
            throw new BadCredentialsException("手机号或密码错误");
        }
        throw new BadCredentialsException("认证失败");
    }
}
```

**前端注册表单组件（SignupForm.vue）**
```vue
<script setup lang="ts">
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const router = useRouter()
const authStore = useAuthStore()

const name = ref('')
const mobile = ref('')
const id_card = ref('')
const password = ref('')
const isSubmitting = ref(false)
const errorMessage = ref('')

const handleSubmit = async () => {
  if (isSubmitting.value) return
  errorMessage.value = ''
  isSubmitting.value = true

  try {
    // 调用注册接口
    await authStore.signup({
      name: name.value,
      mobile: mobile.value,
      id_card: id_card.value,
      password: password.value,
    })
    // 注册成功后自动登录
    await authStore.login({
      mobile: mobile.value,
      password: password.value,
    })
    router.push({ path: '/' })
  } catch (error) {
    errorMessage.value = error instanceof Error ? error.message : '注册失败，请重试'
  } finally {
    isSubmitting.value = false
  }
}
</script>
```

### 1.2 患者端功能区概览

登录后，患者进入患者端仪表盘，左侧边栏包含以下功能模块：

| 功能区 | 说明 |
|--------|------|
| **首页** | 展示问诊统计和最近问诊记录，提供快捷入口 |
| **我的问诊** | 查看所有历史问诊记录，支持进入聊天继续对话 |
| **问诊人管理** | 管理需要就诊的人员信息（如本人、家属） |
| **发起问诊** | 三步向导式创建新问诊：选医生→选问诊人→描述病情 |
| **医生列表** | 浏览所有科室及可接诊医生信息 |

**患者端侧边栏导航配置（PatientDashboard.vue）**
```vue
<script setup lang="ts">
import { computed } from 'vue'
import { useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth'
import { MessageSquare, Users, Plus, UserRound, Stethoscope, LogOut } from 'lucide-vue-next'

const router = useRouter()
const authStore = useAuthStore()

const user = computed(() => authStore.user)
const userInitial = computed(() => user.value?.name?.charAt(0) || 'U')

// 导航菜单配置
const navItems = [
  { title: '首页', url: '/patient', icon: UserRound },
  { title: '我的问诊', url: '/patient/inquiries', icon: MessageSquare },
  { title: '问诊人管理', url: '/patient/profiles', icon: Users },
  { title: '发起问诊', url: '/patient/new-inquiry', icon: Plus },
  { title: '医生列表', url: '/patient/doctors', icon: Stethoscope },
]

function handleLogout() {
  authStore.logout()
  router.push('/login')
}

function navigateTo(url: string) {
  router.push(url)
}
</script>
```

**患者首页 - 逻辑实现（PatientHome.vue - Script）**
```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import { getPatientInquiries, getMyPatientProfiles } from '@/lib/api'
import type { InquiryDto, PatientProfileDto } from '@/lib/api'
// 引入 Shadcn-vue UI 组件
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { MessageSquare, Users, Plus } from 'lucide-vue-next'

const router = useRouter()
const inquiries = ref<InquiryDto[]>([])
const profiles = ref<PatientProfileDto[]>([])

const statusMap: Record<string, { label: string; variant: 'default' | 'secondary' | 'outline' }> = {
  PENDING: { label: '待接诊', variant: 'secondary' },
  IN_PROGRESS: { label: '进行中', variant: 'default' },
  COMPLETED: { label: '已结束', variant: 'outline' },
}

onMounted(async () => {
  const [inquiryData, profileData] = await Promise.all([
    getPatientInquiries(),
    getMyPatientProfiles(),
  ])
  inquiries.value = inquiryData.slice(0, 5)
  profiles.value = profileData
})
</script>
```

**患者首页 - UI 构建（PatientHome.vue - Template）**
```vue
<template>
  <div class="space-y-6">
    <!-- 使用 Shadcn-vue 的 Card 组件构建统计卡片 -->
    <div class="grid gap-4 md:grid-cols-3">
      <Card class="cursor-pointer hover:bg-muted/50 transition-colors" @click="router.push('/patient/inquiries')">
        <CardHeader class="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle class="text-sm font-medium">我的问诊</CardTitle>
          <MessageSquare class="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div class="text-2xl font-bold">{{ inquiries.length }}</div>
          <p class="text-xs text-muted-foreground">条问诊记录</p>
        </CardContent>
      </Card>

      <Card class="cursor-pointer hover:bg-muted/50 transition-colors" @click="router.push('/patient/profiles')">
        <CardHeader class="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle class="text-sm font-medium">问诊人</CardTitle>
          <Users class="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div class="text-2xl font-bold">{{ profiles.length }}</div>
          <p class="text-xs text-muted-foreground">个问诊人</p>
        </CardContent>
      </Card>
    </div>

    <!-- 最近问诊列表 -->
    <Card>
      <CardHeader>
        <CardTitle>最近问诊</CardTitle>
        <CardDescription>您最近的问诊记录</CardDescription>
      </CardHeader>
      <CardContent>
        <div v-for="inquiry in inquiries" :key="inquiry.id" class="flex items-center justify-between p-4 border rounded-lg">
          <div>
            <span class="font-medium">{{ inquiry.doctor.name }}</span>
            <span class="text-muted-foreground ml-2">{{ inquiry.doctor.department_name }}</span>
          </div>
          <!-- 使用 Badge 组件显示状态 -->
          <Badge :variant="statusMap[inquiry.status]?.variant ?? 'secondary'">
            {{ statusMap[inquiry.status]?.label ?? inquiry.status }}
          </Badge>
        </div>
      </CardContent>
    </Card>
  </div>
</template>
```

> **Shadcn-vue 组件说明：**
> - `Card/CardHeader/CardContent/CardTitle`：卡片容器组件，提供一致的视觉层次
> - `Button`：按钮组件，支持多种变体（default、outline、ghost 等）
> - `Badge`：徽章组件，用于显示状态标签
> - `Sidebar`：侧边栏组件，支持可折叠、图标模式等特性
> - 所有组件基于 Tailwind CSS，支持完全自定义样式
> - 组件通过 `@/components/ui/` 别名导入，安装命令：`npx shadcn-vue@latest add <component-name>`

---

## 二、医生端功能区介绍

### 2.1 医生登录

医生使用与患者相同的登录入口，系统根据用户角色（`DOCTOR`）自动跳转至医生工作台。

**演示内容：** 使用医生账号登录，系统自动跳转到医生端。

**前端路由守卫 - 角色重定向（index.ts）**
```typescript
import { createRouter, createWebHistory } from 'vue-router'
import { useAuthStore } from '@/stores/auth'
import { pinia } from '@/stores'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      redirect: () => {
        const authStore = useAuthStore(pinia)
        if (!authStore.isAuthenticated) return '/login'
        // 根据角色自动重定向到对应端
        switch (authStore.userRole) {
          case 'DOCTOR':
            return '/doctor'
          case 'ADMIN':
            return '/admin'
          default:
            return '/patient'
        }
      },
    },
    // ... 其他路由配置
  ],
})

// 路由守卫：验证登录状态
router.beforeEach((to, _from, next) => {
  const authStore = useAuthStore(pinia)
  const requiresAuth = to.matched.some((record) => record.meta?.requiresAuth)
  const isAuthRoute = to.name === 'login' || to.name === 'signup'

  if (requiresAuth && !authStore.isAuthenticated) {
    next({ name: 'login' })
    return
  }
  if (isAuthRoute && authStore.isAuthenticated) {
    next({ path: '/' })
    return
  }
  next()
})
```

### 2.2 医生端功能区概览

医生登录后进入医生工作台，左侧边栏包含以下功能模块：

| 功能区 | 说明 |
|--------|------|
| **工作台** | 展示待接诊、进行中、已完成的问诊统计和最近问诊 |
| **待接诊** | 查看等待医生接诊的患者列表，可点击接受问诊 |
| **进行中** | 查看正在进行的问诊会话，点击进入聊天界面继续对话 |

**医生端侧边栏导航配置（DoctorDashboard.vue）**
```vue
<script setup lang="ts">
import { computed } from 'vue'
import { useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth'
import { MessageSquare, Clock, Stethoscope, LogOut, ChevronsUpDown } from 'lucide-vue-next'

const router = useRouter()
const authStore = useAuthStore()

const user = computed(() => authStore.user)
const userInitial = computed(() => user.value?.name?.charAt(0) || 'D')

// 医生端导航菜单配置
const navItems = [
  { title: '工作台', url: '/doctor', icon: Stethoscope },
  { title: '待接诊', url: '/doctor/pending', icon: Clock },
  { title: '进行中', url: '/doctor/in-progress', icon: MessageSquare },
]

function handleLogout() {
  authStore.logout()
  router.push('/login')
}

function navigateTo(url: string) {
  router.push(url)
}
</script>
```

**医生工作台首页 - 数据加载（DoctorHome.vue）**
```vue
<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth'
import { getPendingInquiries, getInProgressInquiries, getDoctorInquiries } from '@/lib/api'
import type { InquiryDto } from '@/lib/api'

const pendingCount = ref(0)
const inProgressCount = ref(0)
const completedCount = ref(0)
const recentInquiries = ref<InquiryDto[]>([])
const loading = ref(true)

let refreshInterval: ReturnType<typeof setInterval> | null = null

async function loadData(silent = false) {
  try {
    if (!silent) loading.value = true
    // 并行请求三个API获取统计数据
    const [pending, inProgress, all] = await Promise.all([
      getPendingInquiries(),
      getInProgressInquiries(),
      getDoctorInquiries(),
    ])
    pendingCount.value = pending.length
    inProgressCount.value = inProgress.length
    completedCount.value = all.filter(i => i.status === 'COMPLETED').length
    recentInquiries.value = all.slice(0, 5)
  } finally {
    loading.value = false
  }
}

onMounted(async () => {
  await loadData()
  // 每5秒自动刷新，以便及时看到新问诊
  refreshInterval = setInterval(() => loadData(true), 5000)
})

onUnmounted(() => {
  if (refreshInterval) clearInterval(refreshInterval)
})
</script>
```

---

## 三、完整问诊流程演示

本章演示患者从创建问诊人、发起问诊、与医生交流，到问诊结束的完整流程。

### 3.1 创建问诊人

患者首次使用需要先添加问诊人（可以是本人或家属）。

**演示内容：** 进入"问诊人管理"，点击"添加问诊人"，填写姓名、性别、出生日期、病史等信息。

**后端控制器 - 问诊人CRUD（PatientProfileController.java）**
```java
@RestController
@RequestMapping("/api/patient-profiles")
public class PatientProfileController {
    private final PatientProfileService patientProfileService;

    @GetMapping
    public List<PatientProfileDto> getMyProfiles(@AuthenticationPrincipal UserPrincipal principal) {
        return patientProfileService.getProfilesByUserId(principal.getId());
    }

    @PostMapping
    public PatientProfileDto createProfile(
            @AuthenticationPrincipal UserPrincipal principal,
            @RequestBody CreatePatientProfileRequest request) {
        return patientProfileService.createProfile(principal.getId(), request);
    }

    @PutMapping("/{id}")
    public PatientProfileDto updateProfile(
            @PathVariable Integer id,
            @AuthenticationPrincipal UserPrincipal principal,
            @RequestBody CreatePatientProfileRequest request) {
        return patientProfileService.updateProfile(id, principal.getId(), request);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProfile(
            @PathVariable Integer id,
            @AuthenticationPrincipal UserPrincipal principal) {
        patientProfileService.deleteProfile(id, principal.getId());
        return ResponseEntity.noContent().build();
    }
}
```

**后端服务层 - 创建问诊人（PatientProfileService.java）**
```java
@Service
public class PatientProfileService {
    private final PatientProfileRepository patientProfileRepository;
    private final UserRepository userRepository;

    @Transactional
    public PatientProfileDto createProfile(Integer userId, CreatePatientProfileRequest request) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("用户不存在"));

        PatientProfile profile = new PatientProfile();
        profile.setUser(user);
        profile.setName(request.name());
        profile.setGender(request.gender());
        profile.setBirthDate(request.birthDate());
        profile.setMedicalHistory(request.medicalHistory());

        return toDto(patientProfileRepository.save(profile));
    }

    @Transactional
    public PatientProfileDto updateProfile(Integer id, Integer userId, CreatePatientProfileRequest request) {
        PatientProfile profile = patientProfileRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("问诊人不存在"));
        
        // 验证问诊人属于当前用户
        if (!profile.getUser().getId().equals(userId)) {
            throw new IllegalArgumentException("无权修改此问诊人");
        }

        profile.setName(request.name());
        profile.setGender(request.gender());
        profile.setBirthDate(request.birthDate());
        profile.setMedicalHistory(request.medicalHistory());

        return toDto(patientProfileRepository.save(profile));
    }
}
```

### 3.2 发起问诊（三步向导）

**演示内容：** 点击"发起问诊"，按向导步骤操作：
1. **步骤1** - 选择科室和医生
2. **步骤2** - 选择问诊人（可新建）
3. **步骤3** - 描述病情，提交问诊

**前端向导组件 - 步骤1：选择医生（NewInquiry.vue）**
```vue
<script setup lang="ts">
import { ref, computed, onMounted, watch } from 'vue'
import { useRouter } from 'vue-router'
import { getDepartments, getDoctorsByDepartment, createInquiry } from '@/lib/api'
import type { DepartmentDto, DoctorDto } from '@/lib/api'

const router = useRouter()
const step = ref(1)

// 数据
const departments = ref<DepartmentDto[]>([])
const doctors = ref<DoctorDto[]>([])

// 选择的内容
const selectedDepartmentId = ref<number | null>(null)
const selectedDoctorId = ref<number | null>(null)
const selectedProfileId = ref<number | null>(null)
const symptomDescription = ref('')

onMounted(async () => {
  departments.value = await getDepartments()
})

// 当科室改变时，加载该科室的医生
watch(selectedDepartmentId, async (deptId) => {
  if (deptId) {
    doctors.value = await getDoctorsByDepartment(deptId)
    selectedDoctorId.value = null
  } else {
    doctors.value = []
  }
})

function canProceed() {
  switch (step.value) {
    case 1: return selectedDoctorId.value !== null
    case 2: return selectedProfileId.value !== null
    case 3: return symptomDescription.value.trim().length > 0
    default: return false
  }
}

async function handleSubmit() {
  if (!selectedProfileId.value || !selectedDoctorId.value) return
  try {
    const inquiry = await createInquiry({
      patient_profile_id: selectedProfileId.value,
      doctor_id: selectedDoctorId.value,
      symptom_description: symptomDescription.value,
    })
    // 创建成功后跳转到聊天页面
    router.push(`/patient/chat/${inquiry.id}`)
  } catch (error) {
    alert(error instanceof Error ? error.message : '创建问诊失败')
  }
}
</script>
```

**后端控制器 - 创建问诊（InquiryController.java）**
```java
@RestController
@RequestMapping("/api/inquiries")
public class InquiryController {
    private final InquiryService inquiryService;

    @PostMapping
    public InquiryDto createInquiry(
            @AuthenticationPrincipal UserPrincipal principal,
            @RequestBody CreateInquiryRequest request) {
        return inquiryService.createInquiry(principal.getId(), request);
    }

    @PostMapping("/{id}/accept")
    public InquiryDto acceptInquiry(
            @PathVariable Integer id,
            @AuthenticationPrincipal UserPrincipal principal) {
        return inquiryService.acceptInquiry(id, principal.getId());
    }

    @PostMapping("/{id}/complete")
    public InquiryDto completeInquiry(
            @PathVariable Integer id,
            @AuthenticationPrincipal UserPrincipal principal) {
        return inquiryService.completeInquiry(id, principal.getId());
    }
}
```

**后端服务层 - 问诊业务逻辑（InquiryService.java）**
```java
@Service
public class InquiryService {
    private final InquiryRepository inquiryRepository;
    private final PatientProfileRepository patientProfileRepository;
    private final DoctorProfileRepository doctorProfileRepository;

    @Transactional
    public InquiryDto createInquiry(Integer userId, CreateInquiryRequest request) {
        PatientProfile patientProfile = patientProfileRepository.findById(request.patientProfileId())
                .orElseThrow(() -> new IllegalArgumentException("问诊人不存在"));
        
        // 验证问诊人属于当前用户
        if (!patientProfile.getUser().getId().equals(userId)) {
            throw new IllegalArgumentException("无权使用此问诊人创建问诊");
        }

        DoctorProfile doctor = doctorProfileRepository.findById(request.doctorId())
                .orElseThrow(() -> new IllegalArgumentException("医生不存在"));

        if (!doctor.getAvailable()) {
            throw new IllegalArgumentException("该医生暂不接诊");
        }

        Inquiry inquiry = new Inquiry();
        inquiry.setPatientProfile(patientProfile);
        inquiry.setDoctor(doctor);
        inquiry.setSymptomDescription(request.symptomDescription());
        inquiry.setStatus(InquiryStatus.PENDING);  // 初始状态：待接诊
        inquiry.setCreatedAt(LocalDateTime.now());

        return toDto(inquiryRepository.save(inquiry));
    }

    @Transactional
    public InquiryDto acceptInquiry(Integer inquiryId, Integer doctorUserId) {
        Inquiry inquiry = inquiryRepository.findById(inquiryId)
                .orElseThrow(() -> new IllegalArgumentException("问诊不存在"));
        
        if (!inquiry.getDoctor().getUser().getId().equals(doctorUserId)) {
            throw new IllegalArgumentException("无权操作此问诊");
        }
        if (inquiry.getStatus() != InquiryStatus.PENDING) {
            throw new IllegalArgumentException("该问诊状态不是待接诊");
        }

        inquiry.setStatus(InquiryStatus.IN_PROGRESS);  // 更新为进行中
        inquiry.setAcceptedAt(LocalDateTime.now());

        return toDto(inquiryRepository.save(inquiry));
    }
}
```

### 3.3 医生接诊

**演示内容：** 医生在"待接诊"列表看到新问诊，点击"接受问诊"按钮。

**前端待接诊列表（PendingInquiries.vue）**
```vue
<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { useRouter } from 'vue-router'
import { getPendingInquiries, acceptInquiry } from '@/lib/api'
import type { InquiryDto } from '@/lib/api'

const router = useRouter()
const inquiries = ref<InquiryDto[]>([])
let refreshInterval: ReturnType<typeof setInterval> | null = null

onMounted(async () => {
  await loadInquiries()
  // 每5秒自动刷新待接诊列表
  refreshInterval = setInterval(() => {
    loadInquiries(true)
  }, 5000)
})

onUnmounted(() => {
  if (refreshInterval) clearInterval(refreshInterval)
})

async function loadInquiries(silent = false) {
  try {
    inquiries.value = await getPendingInquiries()
  } catch (error) {
    console.error('加载待接诊列表失败:', error)
  }
}

async function handleAccept(inquiry: InquiryDto) {
  try {
    await acceptInquiry(inquiry.id)
    // 接诊成功后跳转到聊天页面
    router.push(`/doctor/chat/${inquiry.id}`)
  } catch (error) {
    alert(error instanceof Error ? error.message : '接受问诊失败')
  }
}
</script>
```

### 3.4 实时聊天交流（WebSocket）

**演示内容：** 医生接诊后，双方进入聊天界面，可实时发送文字消息和图片。

**前端 WebSocket Store - 连接管理（websocket.ts）**
```typescript
import { ref, computed } from 'vue'
import { defineStore } from 'pinia'
import type { MessageDto, MessageType } from '@/lib/api'
import { useAuthStore } from './auth'

const WS_BASE_URL = 'ws://localhost:8081/hi'

export const useWebSocketStore = defineStore('websocket', () => {
  const authStore = useAuthStore()
  
  const socket = ref<WebSocket | null>(null)
  const status = ref<WebSocketStatus>('disconnected')
  const currentInquiryId = ref<number | null>(null)
  const messages = ref<MessageDto[]>([])

  const isConnected = computed(() => status.value === 'connected')

  function connect(inquiryId: number, preserveMessages = false) {
    if (socket.value?.readyState === WebSocket.OPEN) {
      if (currentInquiryId.value === inquiryId) return
      disconnect()
    }

    const token = authStore.token
    if (!token) return

    status.value = 'connecting'
    currentInquiryId.value = inquiryId
    if (!preserveMessages) messages.value = []

    // 建立WebSocket连接，附带token和问诊ID
    const wsUrl = `${WS_BASE_URL}/ws/chat?token=${token}&inquiryId=${inquiryId}`
    socket.value = new WebSocket(wsUrl)

    socket.value.onopen = () => {
      status.value = 'connected'
    }

    socket.value.onmessage = (event) => {
      const data = JSON.parse(event.data)
      if (data.type === 'message' && data.data) {
        messages.value.push(data.data)
      }
    }

    socket.value.onclose = (e) => {
      status.value = 'disconnected'
      // 非正常关闭则3秒后重连
      if (e.code !== 1000 && currentInquiryId.value === inquiryId) {
        setTimeout(() => connect(inquiryId), 3000)
      }
    }
  }

  function sendMessage(content: string, msgType: MessageType = 'TEXT') {
    if (!socket.value || socket.value.readyState !== WebSocket.OPEN) {
      return false
    }
    socket.value.send(JSON.stringify({ type: 'message', content, msgType }))
    return true
  }

  return { status, isConnected, messages, connect, disconnect, sendMessage }
})
```

**后端 WebSocket Handler（ChatWebSocketHandler.java）**
```java
@Component
public class ChatWebSocketHandler extends TextWebSocketHandler {
    private final ObjectMapper objectMapper;
    private final JwtService jwtService;
    private final MessageService messageService;
    private final InquiryService inquiryService;

    // 存储 WebSocket 会话: inquiryId -> Map<userId, session>
    private final Map<Integer, Map<Integer, WebSocketSession>> inquirySessions = new ConcurrentHashMap<>();
    private final Map<String, SessionInfo> sessionInfoMap = new ConcurrentHashMap<>();

    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        String query = session.getUri().getQuery();
        Map<String, String> params = parseQueryParams(query);
        
        String token = params.get("token");
        String inquiryIdStr = params.get("inquiryId");

        // 验证token并提取用户信息
        String mobile = jwtService.extractMobile(token);
        var userOpt = userRepository.findByMobile(mobile);
        Integer userId = userOpt.get().getId();
        Integer inquiryId = Integer.parseInt(inquiryIdStr);

        // 验证用户是否有权访问该问诊
        if (!inquiryService.canAccessInquiry(inquiryId, userId)) {
            session.close(CloseStatus.BAD_DATA.withReason("无权访问该问诊"));
            return;
        }

        // 注册会话
        sessionInfoMap.put(session.getId(), new SessionInfo(userId, inquiryId));
        inquirySessions.computeIfAbsent(inquiryId, k -> new ConcurrentHashMap<>())
                .put(userId, session);

        sendMessage(session, new WebSocketResponse("connected", "连接成功", null));
    }

    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        SessionInfo sessionInfo = sessionInfoMap.get(session.getId());
        JsonNode jsonNode = objectMapper.readTree(message.getPayload());
        
        if ("message".equals(jsonNode.get("type").asText())) {
            String content = jsonNode.get("content").asText();
            String msgType = jsonNode.get("msgType").asText();
            
            // 保存消息到数据库
            MessageDto savedMessage = messageService.saveMessage(
                    sessionInfo.inquiryId(),
                    sessionInfo.userId(),
                    MessageType.valueOf(msgType),
                    content
            );

            // 广播消息给该问诊的所有参与者（患者+医生）
            broadcastToInquiry(sessionInfo.inquiryId(), 
                new WebSocketResponse("message", null, savedMessage));
        }
    }

    private void broadcastToInquiry(Integer inquiryId, WebSocketResponse response) {
        Map<Integer, WebSocketSession> sessions = inquirySessions.get(inquiryId);
        if (sessions != null) {
            sessions.values().forEach(session -> {
                try {
                    sendMessage(session, response);
                } catch (IOException e) {
                    System.err.println("发送消息失败: " + e.getMessage());
                }
            });
        }
    }
}
```

**前端聊天界面（ChatView.vue）**
```vue
<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, watch } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth'
import { useWebSocketStore } from '@/stores/websocket'
import { getInquiryById, getMessagesByInquiry, completeInquiry, uploadFile } from '@/lib/api'
import type { InquiryDto } from '@/lib/api'

const route = useRoute()
const router = useRouter()
const authStore = useAuthStore()
const wsStore = useWebSocketStore()

const inquiry = ref<InquiryDto | null>(null)
const inputMessage = ref('')
const inquiryId = computed(() => parseInt(route.params.id as string))
const isDoctor = computed(() => authStore.isDoctor)
const canChat = computed(() => inquiry.value?.status === 'IN_PROGRESS')

onMounted(async () => {
  // 加载问诊信息和历史消息
  inquiry.value = await getInquiryById(inquiryId.value)
  const messages = await getMessagesByInquiry(inquiryId.value)
  wsStore.setInitialMessages(messages)
  
  // 连接WebSocket（保留历史消息）
  wsStore.connect(inquiryId.value, true)
})

onUnmounted(() => {
  wsStore.disconnect()
})

function sendMessage() {
  if (!inputMessage.value.trim() || !canChat.value) return
  wsStore.sendMessage(inputMessage.value.trim(), 'TEXT')
  inputMessage.value = ''
}

async function handleFileChange(file: File) {
  try {
    const result = await uploadFile(file)
    wsStore.sendMessage(result.url, 'IMAGE')
  } catch (error) {
    alert('图片上传失败')
  }
}

async function handleComplete() {
  if (!inquiry.value || !confirm('确定要结束本次问诊吗？')) return
  try {
    inquiry.value = await completeInquiry(inquiry.value.id)
  } catch (error) {
    alert(error instanceof Error ? error.message : '结束问诊失败')
  }
}
</script>
```

### 3.5 结束问诊

**演示内容：** 医生点击"结束问诊"按钮，问诊状态更新为 `COMPLETED`，双方无法继续发送消息。

**后端服务层 - 结束问诊（InquiryService.java）**
```java
@Transactional
public InquiryDto completeInquiry(Integer inquiryId, Integer doctorUserId) {
    Inquiry inquiry = inquiryRepository.findById(inquiryId)
            .orElseThrow(() -> new IllegalArgumentException("问诊不存在"));
    
    // 验证是否是该医生的问诊
    if (!inquiry.getDoctor().getUser().getId().equals(doctorUserId)) {
        throw new IllegalArgumentException("无权操作此问诊");
    }

    if (inquiry.getStatus() != InquiryStatus.IN_PROGRESS) {
        throw new IllegalArgumentException("该问诊状态不是进行中");
    }

    inquiry.setStatus(InquiryStatus.COMPLETED);
    inquiry.setCompletedAt(LocalDateTime.now());

    return toDto(inquiryRepository.save(inquiry));
}
```

**问诊状态枚举（InquiryStatus.java）**
```java
public enum InquiryStatus {
    PENDING,        // 待接诊
    IN_PROGRESS,    // 进行中
    COMPLETED       // 已完成
}
```

---

## 四、重要设计说明

### 4.1 JWT 身份认证

系统采用 JWT（JSON Web Token）进行无状态身份认证，token有效期为10小时。

**JWT 服务（JwtService.java）**
```java
@Service
public class JwtService {
    String generateToken(String mobile) {
        Map<String, Object> claims = new HashMap<>();

        return Jwts.builder()
                .claims(claims)
                .subject(mobile)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 10))  // 10小时
                .signWith(getKey())
                .compact();
    }

    private SecretKey getKey() {
        byte[] keyBytes = "aWoionFNOAINwonodaohtyioifbbeutwqzwdddWfoqwrznvWSaWapspnf".getBytes();
        return io.jsonwebtoken.security.Keys.hmacShaKeyFor(keyBytes);
    }

    public String extractMobile(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public boolean validToken(String token, UserDetails userDetails) {
        final String mobile = extractMobile(token);
        return (mobile.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }
}
```

**JWT 过滤器配置（JwtFilter.java + SecurityConfig.java）**
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsService userDetailsService;
    private final JwtFilter jwtFilter;

    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .cors(Customizer.withDefaults())
            .authorizeHttpRequests(authorize -> authorize
                .requestMatchers("/signup", "/login").permitAll()
                .requestMatchers("/ws/**").permitAll()  // WebSocket 端点
                .requestMatchers("/api/files/**").permitAll()  // 文件访问
                .requestMatchers("/api/departments").permitAll()  // 公开科室
                .requestMatchers("/api/doctors/public/**").permitAll()  // 公开医生信息
                .anyRequest().authenticated()
            )
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### 4.2 基于角色的访问控制（RBAC）

系统定义了三种用户角色：`PATIENT`（患者）、`DOCTOR`（医生）、`ADMIN`（管理员）。

**用户实体 - 角色字段（User.java）**
```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    @Mobile
    private String mobile;
    
    @NotBlank
    private String password;
    
    private String name;
    
    @Column(unique = true, length = 18)
    private String idCard;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role = Role.PATIENT;  // 默认为患者
    
    @Column(nullable = false)
    private Boolean enabled = true;  // 账号是否启用
}
```

**前端路由守卫 - 角色验证（index.ts）**
```typescript
{
  path: '/patient',
  component: () => import('@/views/patient/PatientDashboard.vue'),
  meta: { requiresAuth: true, role: 'PATIENT' },
  children: [
    // 患者端子路由
  ]
},
{
  path: '/doctor',
  component: () => import('@/views/doctor/DoctorDashboard.vue'),
  meta: { requiresAuth: true, role: 'DOCTOR' },
  children: [
    // 医生端子路由
  ]
},
{
  path: '/admin',
  component: () => import('@/views/admin/AdminDashboard.vue'),
  meta: { requiresAuth: true, role: 'ADMIN' },
  children: [
    // 管理员端子路由
  ]
}
```

### 4.3 WebSocket 实时通信架构

系统采用原生 WebSocket 实现医患实时聊天，支持断线重连和消息持久化。

**WebSocket 配置（WebSocketConfig.java）**
```java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    private final ChatWebSocketHandler chatWebSocketHandler;

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(chatWebSocketHandler, "/ws/chat")
                .setAllowedOrigins("*");
    }
}
```

**连接管理设计：**
- 使用 `ConcurrentHashMap` 存储会话：`inquiryId -> Map<userId, session>`
- 支持同一问诊的多个参与者（患者、医生）同时在线
- 消息广播机制：一人发送，所有参与者实时接收
- 消息先存数据库再广播，确保消息不丢失

**前端断线重连机制（websocket.ts）**
```typescript
socket.value.onclose = (e) => {
  status.value = 'disconnected'
  // 非正常关闭（非用户主动断开）则3秒后重连
  if (e.code !== 1000 && currentInquiryId.value === inquiryId) {
    setTimeout(() => {
      if (currentInquiryId.value === inquiryId) {
        connect(inquiryId)
      }
    }, 3000)
  }
}
```

### 4.4 消息持久化

所有聊天消息存储在 `Message` 表中，支持文字（TEXT）和图片（IMAGE）两种类型。

**消息服务层（MessageService.java）**
```java
@Service
public class MessageService {
    private final MessageRepository messageRepository;
    private final InquiryRepository inquiryRepository;
    private final UserRepository userRepository;

    @Transactional
    public MessageDto saveMessage(Integer inquiryId, Integer senderId, MessageType type, String content) {
        Inquiry inquiry = inquiryRepository.findById(inquiryId)
                .orElseThrow(() -> new IllegalArgumentException("问诊不存在"));
        
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new IllegalArgumentException("用户不存在"));

        Message message = new Message();
        message.setInquiry(inquiry);
        message.setSender(sender);
        message.setType(type);
        message.setContent(content);

        return toDto(messageRepository.save(message));
    }

    public List<MessageDto> getMessagesByInquiryId(Integer inquiryId) {
        return messageRepository.findByInquiryIdOrderByCreatedAtAsc(inquiryId).stream()
                .map(this::toDto)
                .collect(Collectors.toList());
    }
}
```

### 4.5 前端状态管理（Pinia）

使用 Pinia 管理全局状态，主要包括：
- **authStore**：用户认证状态、token、用户信息
- **websocketStore**：WebSocket 连接状态、消息列表

**认证 Store（auth.ts）**
```typescript
export const useAuthStore = defineStore('auth', () => {
  const token = ref<string | null>(getInitialToken())
  const user = ref<UserResponse | null>(getInitialUser())
  const isAuthenticated = computed(() => Boolean(token.value))
  const userRole = computed<Role | null>(() => user.value?.role ?? null)
  const isPatient = computed(() => userRole.value === 'PATIENT')
  const isDoctor = computed(() => userRole.value === 'DOCTOR')
  const isAdmin = computed(() => userRole.value === 'ADMIN')

  async function login(payload: LoginPayload) {
    const response = await loginRequest(payload)
    setToken(response.token)
    setUser(response.user)
    return response
  }

  function logout() {
    setToken(null)
    setUser(null)
  }

  return {
    token, user, isAuthenticated, userRole,
    isPatient, isDoctor, isAdmin,
    login, logout
  }
})
```

### 4.6 后台管理功能

管理员端提供系统管理功能，包括用户管理、科室管理、医生管理等。

**后端控制器 - 用户管理（AdminController.java）**
```java
@RestController
@RequestMapping("/api/admin")
public class AdminController {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    // 获取所有用户
    @GetMapping("/users")
    public List<UserResponse> getAllUsers() {
        return userRepository.findAll().stream()
                .map(UserResponse::fromUser)
                .toList();
    }

    // 搜索用户
    @GetMapping("/users/search")
    public List<UserResponse> searchUsers(@RequestParam String keyword) {
        return userRepository.findAll().stream()
                .filter(u -> (u.getMobile() != null && u.getMobile().contains(keyword)) 
                        || (u.getName() != null && u.getName().contains(keyword)))
                .map(UserResponse::fromUser)
                .toList();
    }

    // 启用/禁用用户
    @PutMapping("/users/{id}/toggle-status")
    public UserResponse toggleUserStatus(@PathVariable Integer id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("用户不存在"));
        user.setEnabled(!user.getEnabled());
        return UserResponse.fromUser(userRepository.save(user));
    }

    // 重置用户密码
    @PutMapping("/users/{id}/reset-password")
    public ResponseEntity<Void> resetPassword(
            @PathVariable Integer id,
            @RequestBody ResetPasswordRequest request) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("用户不存在"));
        user.setPassword(passwordEncoder.encode(request.newPassword()));
        userRepository.save(user);
        return ResponseEntity.noContent().build();
    }
}
```

**前端管理界面 - 用户管理（PatientManagement.vue）**
```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { getAllPatients, toggleUserStatus, resetUserPassword } from '@/lib/api'
import type { UserResponse } from '@/lib/api'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'

const patients = ref<UserResponse[]>([])
const loading = ref(true)

onMounted(async () => {
  try {
    patients.value = await getAllPatients()
  } finally {
    loading.value = false
  }
})

async function handleToggleStatus(id: number) {
  try {
    await toggleUserStatus(id)
    // 刷新列表
    patients.value = await getAllPatients()
  } catch (error) {
    alert(error instanceof Error ? error.message : '操作失败')
  }
}
</script>

<template>
  <div class="space-y-4">
    <h2 class="text-2xl font-bold">患者管理</h2>
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>姓名</TableHead>
          <TableHead>手机号</TableHead>
          <TableHead>状态</TableHead>
          <TableHead>操作</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        <TableRow v-for="patient in patients" :key="patient.id">
          <TableCell>{{ patient.name }}</TableCell>
          <TableCell>{{ patient.mobile }}</TableCell>
          <TableCell>
            <Badge :variant="patient.enabled ? 'default' : 'secondary'">
              {{ patient.enabled ? '启用' : '禁用' }}
            </Badge>
          </TableCell>
          <TableCell>
            <Button size="sm" @click="handleToggleStatus(patient.id)">
              {{ patient.enabled ? '禁用' : '启用' }}
            </Button>
          </TableCell>
        </TableRow>
      </TableBody>
    </Table>
  </div>
</template>
```

> **管理功能说明：**
> - 用户管理：查看、搜索、启用/禁用用户账号，重置密码
> - 科室管理：创建、编辑、删除科室信息
> - 医生管理：管理医生资料、分配科室、设置接诊状态
> - 所有管理操作需要 `ADMIN` 角色权限

### 4.7 数据库设计要点

- **用户表（users）**：存储所有用户（患者、医生、管理员）
- **医生档案表（doctor_profiles）**：存储医生专业信息
- **问诊人表（patient_profiles）**：患者可为多人创建档案
- **问诊表（inquiries）**：记录问诊会话，关联患者档案和医生
- **消息表（messages）**：存储聊天记录
- **科室表（departments）**：医生分类管理

**关键外键关系：**
- `Inquiry.patient_profile_id` → `PatientProfile.id`
- `Inquiry.doctor_id` → `DoctorProfile.id`
- `Message.inquiry_id` → `Inquiry.id`
- `Message.sender_id` → `User.id`

### 4.8 技术栈总结

**后端：**
- Spring Boot 3.5.6
- Spring Security + JWT
- Spring Data JPA + PostgreSQL 18
- WebSocket (原生)
- Java 21

**前端：**
- Vue 3 + TypeScript
- Vite
- Vue Router + Pinia
- Shadcn-vue (UI组件库)
- Tailwind CSS

---

## 总结

本系统实现了完整的在线问诊流程：
1. 患者注册并添加问诊人信息
2. 患者通过三步向导选择医生、问诊人并描述病情
3. 医生在待接诊列表接受问诊
4. 双方通过 WebSocket 实时聊天交流
5. 医生结束问诊，记录归档

核心技术特点：
- JWT 无状态认证
- 基于角色的访问控制
- WebSocket 实时双向通信
- 消息持久化与断线重连
- 响应式 UI 设计

---

**文档结束**
